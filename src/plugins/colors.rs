use super::parser::{parse_metadata, parse_colors, Colors};
use std::fs;
use std::path::Path;
use std::process::Command;
use std::io::{self, Write};


pub fn apply_theme(theme_name: &str, home: &str) -> Result<(), Box<dyn std::error::Error>> {
    // 1. Parse metadata to know what to generate
    let base_path = format!("{}/.config/themey/themes/{}", home, theme_name);
    let metadata_path = format!("{}/metadata.toml", base_path);
    let metadata = parse_metadata(&metadata_path)?;
    
    // 2. Parse colors from the theme file
    let theme_file = &metadata.files[0];
    let theme_path = format!("{}/{}", base_path, theme_file);
    let colors = parse_colors(&theme_path)?;
    
    // 3. Generate files for each target
    for target in &metadata.targets {
        match target.as_str() {
            "kitty" => generate_kitty_config(&colors, home)?,
            "waybar" => generate_waybar_config(&colors, home)?,
            "hyprland" => generate_hyprland_config(&colors, home)?,
            "rofi" => generate_rofi_config(&colors, home)?,
            "dunst" => generate_dunst_config(&colors, home)?,
            _ => eprintln!("Unknown target: {}", target),
        }
    }
    
    println!("Applied theme '{}' by {}", metadata.name, metadata.author);
    Ok(())
}

fn generate_kitty_config(colors: &Colors, home: &str) -> Result<(), Box<dyn std::error::Error>> {
    let config_path = format!("{}/.config/kitty/colors.conf", home);
    let content = format!(
        "# Kitty color config - Generated by themey
foreground {foreground}
background {background}
cursor {cursor}

# Normal colors
color0 {black}
color1 {red}
color2 {green}
color3 {yellow}
color4 {blue}
color5 {magenta}
color6 {cyan}
color7 {white}

# Bright colors
color8 {bright_black}
color9 {bright_red}
color10 {bright_green}
color11 {bright_yellow}
color12 {bright_blue}
color13 {bright_magenta}
color14 {bright_cyan}
color15 {bright_white}
",
        foreground = colors.special.foreground,
        background = colors.special.background,
        cursor = colors.special.cursor,
        black = colors.normal.black,
        red = colors.normal.red,
        green = colors.normal.green,
        yellow = colors.normal.yellow,
        blue = colors.normal.blue,
        magenta = colors.normal.magenta,
        cyan = colors.normal.cyan,
        white = colors.normal.white,
        bright_black = colors.bright.black,
        bright_red = colors.bright.red,
        bright_green = colors.bright.green,
        bright_yellow = colors.bright.yellow,
        bright_blue = colors.bright.blue,
        bright_magenta = colors.bright.magenta,
        bright_cyan = colors.bright.cyan,
        bright_white = colors.bright.white,
    );
    
    if let Some(parent) = Path::new(&config_path).parent() {
        fs::create_dir_all(parent)?;
    }
    
    fs::write(&config_path, content)?;
    let result = Command::new("killall")
        .args(["-SIGUSR1", "kitty"])
        .output();
    
    match result {
        Ok(_) => println!("  ↻ Reloaded kitty"),
        Err(_) => println!("  ⚠ Could not reload kitty (not running?)"),
    }
    
    Ok(())
}

fn generate_waybar_config(colors: &Colors, home: &str) -> Result<(), Box<dyn std::error::Error>> {
    let config_path = format!("{}/.config/waybar/colors.css", home);
    let content = format!(
        "/* Waybar colors - Generated by themey */
@define-color background {background};
@define-color foreground {foreground};
@define-color cursor {cursor};

@define-color black {black};
@define-color red {red};
@define-color green {green};
@define-color yellow {yellow};
@define-color blue {blue};
@define-color magenta {magenta};
@define-color cyan {cyan};
@define-color white {white};

@define-color bright-black {bright_black};
@define-color bright-red {bright_red};
@define-color bright-green {bright_green};
@define-color bright-yellow {bright_yellow};
@define-color bright-blue {bright_blue};
@define-color bright-magenta {bright_magenta};
@define-color bright-cyan {bright_cyan};
@define-color bright-white {bright_white};
",
        background = colors.special.background,
        foreground = colors.special.foreground,
        cursor = colors.special.cursor,
        black = colors.normal.black,
        red = colors.normal.red,
        green = colors.normal.green,
        yellow = colors.normal.yellow,
        blue = colors.normal.blue,
        magenta = colors.normal.magenta,
        cyan = colors.normal.cyan,
        white = colors.normal.white,
        bright_black = colors.bright.black,
        bright_red = colors.bright.red,
        bright_green = colors.bright.green,
        bright_yellow = colors.bright.yellow,
        bright_blue = colors.bright.blue,
        bright_magenta = colors.bright.magenta,
        bright_cyan = colors.bright.cyan,
        bright_white = colors.bright.white,
    );
    
    if let Some(parent) = Path::new(&config_path).parent() {
        fs::create_dir_all(parent)?;
    }
    
    fs::write(&config_path, content)?;
    let result = Command::new("killall")
        .args(["-SIGUSR2", "waybar"])
        .output();
    
    match result {
        Ok(_) => println!("  ↻ Reloaded waybar"),
        Err(_) => println!("  ⚠ Could not reload waybar (not running?)"),
    }
    
    Ok(())
}

fn generate_hyprland_config(colors: &Colors, home: &str) -> Result<(), Box<dyn std::error::Error>> {
    let config_path = format!("{}/.config/hypr/colors.conf", home);
    let content = format!(
        "# Hyprland colors - Generated by themey
$background = rgb({background})
$foreground = rgb({foreground})
$cursor = rgb({cursor})

$black = rgb({black})
$red = rgb({red})
$green = rgb({green})
$yellow = rgb({yellow})
$blue = rgb({blue})
$magenta = rgb({magenta})
$cyan = rgb({cyan})
$white = rgb({white})

$bright_black = rgb({bright_black})
$bright_red = rgb({bright_red})
$bright_green = rgb({bright_green})
$bright_yellow = rgb({bright_yellow})
$bright_blue = rgb({bright_blue})
$bright_magenta = rgb({bright_magenta})
$bright_cyan = rgb({bright_cyan})
$bright_white = rgb({bright_white})

# Border colors
general {{
    col.active_border = $cyan $blue 45deg
    col.inactive_border = $black
}}
",
        background = hex_to_rgb(&colors.special.background),
        foreground = hex_to_rgb(&colors.special.foreground),
        cursor = hex_to_rgb(&colors.special.cursor),
        black = hex_to_rgb(&colors.normal.black),
        red = hex_to_rgb(&colors.normal.red),
        green = hex_to_rgb(&colors.normal.green),
        yellow = hex_to_rgb(&colors.normal.yellow),
        blue = hex_to_rgb(&colors.normal.blue),
        magenta = hex_to_rgb(&colors.normal.magenta),
        cyan = hex_to_rgb(&colors.normal.cyan),
        white = hex_to_rgb(&colors.normal.white),
        bright_black = hex_to_rgb(&colors.bright.black),
        bright_red = hex_to_rgb(&colors.bright.red),
        bright_green = hex_to_rgb(&colors.bright.green),
        bright_yellow = hex_to_rgb(&colors.bright.yellow),
        bright_blue = hex_to_rgb(&colors.bright.blue),
        bright_magenta = hex_to_rgb(&colors.bright.magenta),
        bright_cyan = hex_to_rgb(&colors.bright.cyan),
        bright_white = hex_to_rgb(&colors.bright.white),
    );
    
    if let Some(parent) = Path::new(&config_path).parent() {
        fs::create_dir_all(parent)?;
    }
    
    fs::write(&config_path, content)?;
    let result = Command::new("hyprctl")
        .args(["reload"])
        .output();
    
    match result {
        Ok(_) => println!("  ↻ Reloaded hyprland"),
        Err(_) => println!("  ⚠ Could not reload hyprland (not running?)"),
    }
    
    Ok(())
}

fn generate_rofi_config(colors: &Colors, home: &str) -> Result<(), Box<dyn std::error::Error>> {
    let config_path = format!("{}/.config/rofi/colors.rasi", home);
    let content = format!(
        "/* Rofi colors - Generated by themey */
* {{
    background: {background};
    background-alt: {bright_black};
    foreground: {foreground};
    border: {blue};
    cursor: {cursor};
    
    black: {black};
    red: {red};
    green: {green};
    yellow: {yellow};
    blue: {blue};
    magenta: {magenta};
    cyan: {cyan};
    white: {white};
    
    bright-black: {bright_black};
    bright-red: {bright_red};
    bright-green: {bright_green};
    bright-yellow: {bright_yellow};
    bright-blue: {bright_blue};
    bright-magenta: {bright_magenta};
    bright-cyan: {bright_cyan};
    bright-white: {bright_white};
    
    background-color: @background;
    text-color: @foreground;
    selected-normal-background: @blue;
    selected-normal-foreground: @background;
}}
",
        background = colors.special.background,
        foreground = colors.special.foreground,
        cursor = colors.special.cursor,
        black = colors.normal.black,
        red = colors.normal.red,
        green = colors.normal.green,
        yellow = colors.normal.yellow,
        blue = colors.normal.blue,
        magenta = colors.normal.magenta,
        cyan = colors.normal.cyan,
        white = colors.normal.white,
        bright_black = colors.bright.black,
        bright_red = colors.bright.red,
        bright_green = colors.bright.green,
        bright_yellow = colors.bright.yellow,
        bright_blue = colors.bright.blue,
        bright_magenta = colors.bright.magenta,
        bright_cyan = colors.bright.cyan,
        bright_white = colors.bright.white,
    );
    
    if let Some(parent) = Path::new(&config_path).parent() {
        fs::create_dir_all(parent)?;
    }
    
    fs::write(&config_path, content)?;
    Ok(())
}

fn generate_dunst_config(colors: &Colors, home: &str) -> Result<(), Box<dyn std::error::Error>> {
    let config_path = format!("{}/.config/dunst/dunstrc.d/colors.conf", home);
    let content = format!(
        "# Dunst colors - Generated by themey
[urgency_low]
background = \"{background}\"
foreground = \"{foreground}\"
frame_color = \"{blue}\"

[urgency_normal]
background = \"{background}\"
foreground = \"{foreground}\"
frame_color = \"{cyan}\"

[urgency_critical]
background = \"{background}\"
foreground = \"{foreground}\"
frame_color = \"{red}\"
",
        background = colors.special.background,
        foreground = colors.special.foreground,
        blue = colors.normal.blue,
        cyan = colors.normal.cyan,
        red = colors.normal.red,
    );
    
    if let Some(parent) = Path::new(&config_path).parent() {
        fs::create_dir_all(parent)?;
    }
    
    fs::write(&config_path, content)?;
    Ok(())
}

fn hex_to_rgb(hex: &str) -> String {
    let hex = hex.trim_start_matches('#');
    format!("{}", hex)
}

pub fn preview_theme_rgb(theme_name: &str, home: &str) -> Result<(), Box<dyn std::error::Error>> {
    let base_path = format!("{}/.config/themey/themes/{}", home, theme_name);
    let metadata_path = format!("{}/metadata.toml", base_path);
    let metadata = parse_metadata(&metadata_path)?;
    
    let theme_file = &metadata.files[0];
    let theme_path = format!("{}/{}", base_path, theme_file);
    let colors = parse_colors(&theme_path)?;
    
    println!("\n  {} by {}\n", metadata.name, metadata.author);
    
    draw_color_panes_rgb(&colors)?;
    
    println!();
    Ok(())
}

fn draw_color_panes_rgb(colors: &Colors) -> Result<(), Box<dyn std::error::Error>> {
    let stdout = io::stdout();
    let mut handle = stdout.lock();
    
    let height = 3;
    let pane_width = 8;
    
    let normal_colors = [
        &colors.normal.black,
        &colors.normal.red,
        &colors.normal.green,
        &colors.normal.yellow,
        &colors.normal.blue,
        &colors.normal.magenta,
        &colors.normal.cyan,
        &colors.normal.white,
    ];
    
    let bright_colors = [
        &colors.bright.black,
        &colors.bright.red,
        &colors.bright.green,
        &colors.bright.yellow,
        &colors.bright.blue,
        &colors.bright.magenta,
        &colors.bright.cyan,
        &colors.bright.white,
    ];
    
    for _ in 0..height {
        for color in &normal_colors {
            let (r, g, b) = hex_to_rgb_tuple(color);
            write!(handle, "\x1b[48;2;{};{};{}m", r, g, b)?;
            write!(handle, "{}", " ".repeat(pane_width))?;
        }
        write!(handle, "\x1b[0m\n")?;
    }
    
    for _ in 0..height {
        for color in &bright_colors {
            let (r, g, b) = hex_to_rgb_tuple(color);
            write!(handle, "\x1b[48;2;{};{};{}m", r, g, b)?;
            write!(handle, "{}", " ".repeat(pane_width))?;
        }
        write!(handle, "\x1b[0m\n")?;
    }
    
    handle.flush()?;
    Ok(())
}

fn hex_to_rgb_tuple(hex: &str) -> (u8, u8, u8) {
    let hex = hex.trim_start_matches('#');
    let r = u8::from_str_radix(&hex[0..2], 16).unwrap_or(0);
    let g = u8::from_str_radix(&hex[2..4], 16).unwrap_or(0);
    let b = u8::from_str_radix(&hex[4..6], 16).unwrap_or(0);
    (r, g, b)
}
